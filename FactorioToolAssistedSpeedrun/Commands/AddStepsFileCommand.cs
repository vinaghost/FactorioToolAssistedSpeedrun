using FactorioToolAssistedSpeedrun.DbContexts;
using FactorioToolAssistedSpeedrun.Entities;
using FactorioToolAssistedSpeedrun.Models;
using Microsoft.EntityFrameworkCore;
using System.IO;
using System.Text;

namespace FactorioToolAssistedSpeedrun.Commands
{
    public class AddStepsFileCommand : ICommand
    {
        public required string FolderLocation { get; init; }
        public required ProjectDbContext DbContext { get; init; }

        public async Task Execute()
        {
            var filePath = Path.Combine(FolderLocation, "steps.lua");
            await using var writer = new StreamWriter(filePath, false, Encoding.UTF8);

            //writer.WriteLine("-- This file was generated by Factorio Tool Assisted Speedrun");
            writer.WriteLine("local step = {} ");
            writer.WriteLine();

            var steps = DbContext.Steps
                .AsNoTracking()
                .Where(s => !s.Modifier.Contains("skip"))
                .OrderBy(s => s.Id)
                .ToList();

            for (int i = 0; i < steps.Count; i++)
            {
                writer.WriteLine(StepFormat(steps[i], i + 1).Replace("__DETAILS__", steps[i].Type.ToLower() switch
                {
                    "walk" => Walk(steps[i]),
                    "mine" => Mine(steps[i]),
                    "craft" => Craft(steps[i]),
                    "tech" => Tech(steps[i]),
                    "speed" => Speed(steps[i]),
                    "pause" => Pause(steps[i]),
                    "never idele" => NeverIdle(steps[i]),
                    "keep walking" => KeepWalking(steps[i]),
                    "keep on path" => KeepOnPath(steps[i]),
                    "keep crafting" => KeepCrafting(steps[i]),
                    "launch" => Launch(steps[i]),
                    "save" => Save(steps[i]),
                    "wait" => Wait(steps[i]),
                    "pick up" => PickUp(steps[i]),
                    "rotate" => Rotate(steps[i]),
                    "build" => Build(steps[i]),
                    "take" => Take(steps[i]),
                    "put" => Put(steps[i]),
                    "recipe" => Recipe(steps[i]),
                    "limit" => Limit(steps[i]),
                    "priority" => Priority(steps[i]),
                    "filter" => Filter(steps[i]),
                    "drop" => Drop(steps[i]),
                    _ => throw new Exception($"Unknown step type: {steps[i].Type}"),
                }));
            }

            writer.WriteLine($"step[{steps.Count}] = {{\"break\"}}");
            writer.WriteLine();
            writer.WriteLine("return step");
        }

        public static string StepFormat(Step step, int count)
        {
            if (step.Type.Equals("save", StringComparison.CurrentCultureIgnoreCase))
            {
                return $"step[{count}] = {{{step.Id}, \"{step.Type.ToLower()}\"__DETAILS__{Modifier(step.Modifier)}}}";
            }

            if (step.Type.Equals("pick up", StringComparison.CurrentCultureIgnoreCase))
            {
                return $"step[{count}] = {{{step.Id}, \"pick\"__DETAILS__{Comment(step.Comment)}{Modifier(step.Modifier)}}}";
            }

            return $"step[{count}] = {{{step.Id}, \"{step.Type.ToLower()}\"__DETAILS__{Comment(step.Comment)}{Modifier(step.Modifier)}}}";
        }

        public static string Comment(string comment)
        {
            return comment == "" ? "" : $", comment = \"{comment}\"";
        }

        public static string Modifier(string modifier)
        {
            var sb = new StringBuilder();
            sb.Append(", ");
            if (modifier.Contains("no order"))
            {
                sb.Append(" no_order = true,");
            }
            if (modifier.Contains("wait for"))
            {
                sb.Append(" wait_for = true,");
            }
            if (modifier.Contains("cancel others"))
            {
                sb.Append(" cancel = true,");
            }
            if (modifier.Contains("walk towards"))
            {
                sb.Append(" walk_towards = true,");
            }
            if (modifier.Contains("all"))
            {
                sb.Append(" all = true,");
            }

            return sb.Length == 2 ? "" : sb.ToString();
        }

        public static string Orientation(string orientation, string entity = "")
        {
            if (Enum.TryParse<InventoryType>(orientation, true, out var inventoryType))
            {
                return inventoryType.GetInventoryDefines(entity);
            }
            if (Enum.TryParse<OrientationType>(orientation, true, out var orientationType))
            {
                return orientationType.GetOrientationDefines();
            }
            return orientation;
        }

        public static string Coordinates(double x, double y)
        {
            return $"{{{x:F6}, {y:F6}}}";
        }

        public static string Amount(int amount)
        {
            return amount == 0 ? "-1" : $"{amount}";
        }

        public static string Walk(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}";
        }

        public static string Mine(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, {Amount(step.Amount)}";
        }

        public static string Craft(Step step)
        {
            return $", {Amount(step.Amount)}, \"{step.Item}\"";
        }

        public static string Tech(Step step)
        {
            return $", \"{step.Item}\"";
        }

        public static string Speed(Step step)
        {
            return $", {step.Amount}";
        }

        public static string Pause(Step _)
        {
            return "";
        }

        public static string NeverIdle(Step _)
        {
            return "";
        }

        public static string KeepWalking(Step _)
        {
            return "";
        }

        public static string KeepOnPath(Step _)
        {
            return "";
        }

        public static string KeepCrafting(Step _)
        {
            return "";
        }

        public static string Launch(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}";
        }

        public static string Save(Step step)
        {
            return $", \"{step.Comment}\"";
        }

        public static string Wait(Step step)
        {
            return $", {step.Amount}";
        }

        public static string PickUp(Step step)
        {
            return $", \"{step.Amount}\"";
        }

        public static string Rotate(Step step)
        {
            if (step.Amount == 3)
                return $", {Coordinates(step.X, step.Y)}, true";
            else
                return $", {Coordinates(step.X, step.Y)}, false";
        }

        public static string Build(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {Orientation(step.Orientation)}";
        }

        public static string Take(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {Amount(step.Amount)}, {Orientation(step.Orientation, step.Item)}";
        }

        public static string Put(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {Amount(step.Amount)}, {Orientation(step.Orientation, step.Item)}";
        }

        public static string Recipe(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\"";
        }

        public static string Limit(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, {step.Amount}, {Orientation(step.Orientation)}";
        }

        public static string Priority(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, {Orientation(step.Orientation)}";
        }

        public static string Filter(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {step.Amount}, {Orientation(step.Orientation)}";
        }

        public static string Drop(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\"";
        }
    }
}