using FactorioToolAssistedSpeedrun.DbContexts;
using FactorioToolAssistedSpeedrun.Entities;
using FactorioToolAssistedSpeedrun.Enums;
using Microsoft.EntityFrameworkCore;
using System.IO;
using System.Text;

namespace FactorioToolAssistedSpeedrun.Commands
{
    public class AddStepsFileCommand : IAsyncCommand
    {
        public required string FolderLocation { get; init; }
        public required ProjectDbContext DbContext { get; init; }

        public async Task Execute()
        {
            var filePath = Path.Combine(FolderLocation, "steps.lua");
            await using var writer = new StreamWriter(filePath, false, Encoding.UTF8);

            //writer.WriteLine("-- This file was generated by Factorio Tool Assisted Speedrun");
            writer.WriteLine("local step = {}");
            writer.WriteLine();

            var steps = DbContext.Steps
                .AsNoTracking()
                .Where(s => !s.IsSkip)
                .OrderBy(s => s.Location)
                .ToList();

            for (int i = 0; i < steps.Count; i++)
            {
                writer.WriteLine(StepFormat(steps[i], i + 1).Replace("__DETAILS__", steps[i].Type switch
                {
                    StepType.Walk => Walk(steps[i]),
                    StepType.Mine => Mine(steps[i]),
                    StepType.Craft => Craft(steps[i]),
                    StepType.Tech => Tech(steps[i]),
                    StepType.Speed => Speed(steps[i]),
                    StepType.Pause => Pause(steps[i]),
                    StepType.NeverIdle => NeverIdle(steps[i]),
                    StepType.KeepWalking => KeepWalking(steps[i]),
                    StepType.KeepOnPath => KeepOnPath(steps[i]),
                    StepType.KeepCrafting => KeepCrafting(steps[i]),
                    StepType.Launch => Launch(steps[i]),
                    StepType.Save => Save(steps[i]),
                    StepType.Wait => Wait(steps[i]),
                    StepType.Pick => PickUp(steps[i]),
                    StepType.Rotate => Rotate(steps[i]),
                    StepType.Build => Build(steps[i]),
                    StepType.Take => Take(steps[i]),
                    StepType.Put => Put(steps[i]),
                    StepType.Recipe => Recipe(steps[i]),
                    StepType.Limit => Limit(steps[i]),
                    StepType.Priority => Priority(steps[i]),
                    StepType.Filter => Filter(steps[i]),
                    StepType.Drop => Drop(steps[i]),
                    _ => throw new Exception($"Unknown step type: {steps[i].Type}"),
                }));
            }

            writer.WriteLine($"step[{steps.Count}] = {{\"break\"}}");
            writer.WriteLine();
            writer.WriteLine("return step");
        }

        public static string StepFormat(Step step, int count)
        {
            if (step.Type == StepType.Save)
            {
                return $"step[{count}] = {{{step.Location}, \"{step.Type.ToStepTypeString()}\"__DETAILS__{Modifier(step.Modifier)}}}";
            }

            return $"step[{count}] = {{{step.Location}, \"{step.Type.ToStepTypeString()}\"__DETAILS__{Comment(step.Comment)}{Modifier(step.Modifier)}}}";
        }

        public static string Comment(string comment)
        {
            return comment == "" ? "" : $", comment = \"{comment}\"";
        }

        public static string Modifier(string modifier)
        {
            var sb = new StringBuilder();
            sb.Append(", ");
            if (modifier.Contains("no order"))
            {
                sb.Append(" no_order = true,");
            }
            if (modifier.Contains("wait for"))
            {
                sb.Append(" wait_for = true,");
            }
            if (modifier.Contains("cancel others"))
            {
                sb.Append(" cancel = true,");
            }
            if (modifier.Contains("walk towards"))
            {
                sb.Append(" walk_towards = true,");
            }
            if (modifier.Contains("all"))
            {
                sb.Append(" all = true,");
            }

            return sb.Length == 2 ? "" : sb.ToString();
        }

        public string OrientationInventory(string orientation, int id = 0, double x = 0, double y = 0)
        {
            if (!Enum.TryParse<InventoryType>(orientation, true, out var inventoryType))
            {
                throw new Exception($"Unknown inventory type: {orientation}");
            }

            if (inventoryType == InventoryType.Input || inventoryType == InventoryType.Modules)
            {
                var entity = DbContext.Buildings
                    .AsNoTracking()
                    .Where(b => Math.Abs(b.X - x) < 0.0001 && Math.Abs(b.Y - y) < 0.0001 && b.BuildStep < id && (b.DestroyStep > id || b.DestroyStep == -1))
                    .FirstOrDefault();
                return inventoryType.GetInventoryDefines(entity?.Name ?? "");
            }

            return inventoryType.GetInventoryDefines();
        }

        public static string Orientation(string orientation)
        {
            if (!Enum.TryParse<OrientationType>(orientation, true, out var orientationType))
            {
                throw new Exception($"Unknown orientation type: {orientation}");
            }
            return orientationType.GetOrientationDefines();
        }

        public static string OrientationPriority(string orientation)
        {
            var segments = orientation.Split(',');
            if (segments.Length != 2)
            {
                throw new Exception($"Unknown orientation priority type: {orientation}");
            }

            var input = segments[0].Trim();
            var output = segments[1].Trim();

            return $"\"{input}\", \"{output}\"";
        }

        public string OrientationFilter(int id, double x, double y)
        {
            var entity = DbContext.Buildings
                   .AsNoTracking()
                   .Where(b => Math.Abs(b.X - x) < 0.0001 && Math.Abs(b.Y - y) < 0.0001 && b.BuildStep < id && (b.DestroyStep > id || b.DestroyStep == -1))
                   .FirstOrDefault() ?? throw new Exception($"Cannot find building at ({x}, {y}) for step {id}");

            if (entity.Name.Contains("splitter"))
            {
                return "\"splitter\"";
            }
            else if (entity.Name.Contains("inserter"))
            {
                return "\"inserter\"";
            }
            else
            {
                throw new Exception($"Unknown entity type for filter orientation: {entity.Name}");
            }
        }

        public static string Coordinates(double x, double y)
        {
            return $"{{{x:F6}, {y:F6}}}";
        }

        public static string Amount(int amount)
        {
            return amount == 0 ? "-1" : $"{amount}";
        }

        public static string Walk(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}";
        }

        public static string Mine(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, {Amount(step.Amount)}";
        }

        public static string Craft(Step step)
        {
            return $", {Amount(step.Amount)}, \"{step.Item}\"";
        }

        public static string Tech(Step step)
        {
            return $", \"{step.Item}\"";
        }

        public static string Speed(Step step)
        {
            return $", {step.Amount}";
        }

        public static string Pause(Step _)
        {
            return "";
        }

        public static string NeverIdle(Step _)
        {
            return "";
        }

        public static string KeepWalking(Step _)
        {
            return "";
        }

        public static string KeepOnPath(Step _)
        {
            return "";
        }

        public static string KeepCrafting(Step _)
        {
            return "";
        }

        public static string Launch(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}";
        }

        public static string Save(Step step)
        {
            return $", \"{step.Comment}\"";
        }

        public static string Wait(Step step)
        {
            return $", {step.Amount}";
        }

        public static string PickUp(Step step)
        {
            return $", \"{step.Amount}\"";
        }

        public static string Rotate(Step step)
        {
            if (step.Amount == 3)
                return $", {Coordinates(step.X, step.Y)}, true";
            else
                return $", {Coordinates(step.X, step.Y)}, false";
        }

        public static string Build(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {Orientation(step.Orientation)}";
        }

        public string Take(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {Amount(step.Amount)}, {OrientationInventory(step.Orientation, step.Location, step.X, step.Y)}";
        }

        public string Put(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {Amount(step.Amount)}, {OrientationInventory(step.Orientation, step.Location, step.X, step.Y)}";
        }

        public static string Recipe(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\"";
        }

        public string Limit(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, {step.Amount}, {OrientationInventory(step.Orientation)}";
        }

        public static string Priority(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, {OrientationPriority(step.Orientation)}";
        }

        public string Filter(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\", {step.Amount},  {OrientationFilter(step.Location, step.X, step.Y)}";
        }

        public static string Drop(Step step)
        {
            return $", {Coordinates(step.X, step.Y)}, \"{step.Item}\"";
        }
    }
}