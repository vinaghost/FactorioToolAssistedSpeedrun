using FactorioToolAssistedSpeedrun.DbContexts;
using FactorioToolAssistedSpeedrun.Entities;
using FactorioToolAssistedSpeedrun.Enums;
using Microsoft.EntityFrameworkCore;
using System.IO;
using System.Text;

namespace FactorioToolAssistedSpeedrun.Commands
{
    public class AddStepsFileCommand : IAsyncCommand
    {
        public required string FolderLocation { get; init; }
        public required ProjectDbContext DbContext { get; init; }

        public async Task Execute()
        {
            var filePath = Path.Combine(FolderLocation, "steps.lua");
            await using var writer = new StreamWriter(filePath, false, Encoding.UTF8);

            //writer.WriteLine("-- This file was generated by Factorio Tool Assisted Speedrun");
            writer.WriteLine("local step = {}");
            writer.WriteLine();

            var steps = DbContext.Steps
                .AsNoTracking()
                .Where(s => !s.IsSkip)
                .OrderBy(s => s.Location)
                .ToList();

            for (int i = 0; i < steps.Count; i++)
            {
                writer.WriteLine(StepFormat(steps[i], i + 1));
            }

            writer.WriteLine($"step[{steps.Count}] = {{\"break\"}}");
            writer.WriteLine();
            writer.WriteLine("return step");
        }

        public string StepFormat(Step step, int count)
        {
            var sb = new StringBuilder();

            var type = step.Type;
            sb.Append($"step[{count}] = {{{step.Location}");
            if (type == StepType.PickUp)
            {
                sb.Append($", \"pick\"");
            }
            else
            {
                sb.Append($", \"{StepTypeExtensions.ToString(type)}\"");
            }
            if (type.ContainFlag(ParameterFlag.Point))
            {
                sb.Append($", {{{step.X:F6}, {step.Y:F6}}}");
            }

            if (type == StepType.Craft)
            {
                if (type.ContainFlag(ParameterFlag.Amount))
                {
                    if (step.Amount < 1)
                        sb.Append($", -1");
                    else
                        sb.Append($", {step.Amount}");
                }
                if (type.ContainFlag(ParameterFlag.Item))
                {
                    sb.Append($", \"{step.Item}\"");
                }
            }
            else
            {
                if (type.ContainFlag(ParameterFlag.Item))
                {
                    sb.Append($", \"{step.Item}\"");
                }

                if (type.ContainFlag(ParameterFlag.Amount))
                {
                    if (type == StepType.Rotate)
                    {
                        if (step.Amount == 3)
                            sb.Append(", true");
                        else
                            sb.Append(", false");
                    }
                    else
                    {
                        if (step.Amount < 1)
                            sb.Append($", -1");
                        else
                            sb.Append($", {step.Amount}");
                    }
                }
            }

            if (type.ContainFlag(ParameterFlag.Orientation))
            {
                sb.Append($", {step.Orientation!.Value.GetOrientationDefines()}");
            }

            if (type.ContainFlag(ParameterFlag.Inventory))
            {
                sb.Append($", {OrientationInventory(step.Inventory!.Value, step.Location, step.X, step.Y)}");
            }

            if (type.ContainFlag(ParameterFlag.Priority))
            {
                sb.Append($", {step.Priority!.ToLuaString()}");
            }

            if (type.ContainFlag(ParameterFlag.Modifier))
            {
                if (step.Type != StepType.Mine && step.Modifier.HasValue)
                {
                    sb.Append($", {ModifierTypeExtensions.ToLuaString(step.Modifier.Value)}");
                }
            }

            if (step.Type == StepType.Filter)
            {
                sb.Append($", {OrientationFilter(step.Location, step.X, step.Y)}");
            }

            if (step.Type == StepType.Save)
            {
                sb.Append($", \"{step.Comment}\"");
            }
            else
            {
                var comment = string.IsNullOrEmpty(step.Comment) ? "" : $", comment = \"{step.Comment}\"";
                sb.Append($"{comment}");
            }
            sb.Append("}");
            return sb.ToString();
        }

        public string OrientationInventory(InventoryType inventoryType, int id = 0, double x = 0, double y = 0)
        {
            if (inventoryType == InventoryType.Input || inventoryType == InventoryType.Modules)
            {
                var entity = DbContext.Buildings
                    .AsNoTracking()
                    .Where(b => Math.Abs(b.X - x) < 0.0001 && Math.Abs(b.Y - y) < 0.0001 && b.BuildStep < id && (b.DestroyStep > id || b.DestroyStep == -1))
                    .FirstOrDefault();
                return inventoryType.GetInventoryDefines(entity?.Name ?? "");
            }

            return inventoryType.GetInventoryDefines();
        }

        public string OrientationFilter(int id, double x, double y)
        {
            var entity = DbContext.Buildings
                   .AsNoTracking()
                   .Where(b => Math.Abs(b.X - x) < 0.0001 && Math.Abs(b.Y - y) < 0.0001 && b.BuildStep < id && (b.DestroyStep > id || b.DestroyStep == -1))
                   .FirstOrDefault() ?? throw new Exception($"Cannot find building at ({x}, {y}) for step {id}");

            if (entity.Name.Contains("splitter"))
            {
                return "\"splitter\"";
            }
            else if (entity.Name.Contains("inserter"))
            {
                return "\"inserter\"";
            }
            else
            {
                throw new Exception($"Unknown entity type for filter orientation: {entity.Name}");
            }
        }
    }
}